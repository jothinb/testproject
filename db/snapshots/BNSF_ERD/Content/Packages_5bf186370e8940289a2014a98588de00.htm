<HTML>
<BODY bgcolor="#ffffff" text="#000000">
<A NAME = "Pack_53088b272b0c4c7ab3ae02ceb34ab64c"></A>
<TABLE WIDTH=100% CELLPADDING=1 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="darkblue" ><B><FONT SIZE=5 COLOR="white" FACE="Arial">DBMS_PIPE&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Owner&nbsp;</FONT></B></TD>
<TD><FONT SIZE=2 FACE="Arial">SYS&nbsp;</FONT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Description&nbsp;</FONT></B></TD>
<TD><FONT SIZE=2 FACE="Arial">&nbsp;</FONT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Header SQL&nbsp;</FONT></B></TD>
<TD><TT><TT>CREATE OR REPLACE package SYS.dbms_pipe is</TT><BR><TT></TT><BR><TT>-- DE-HEAD&nbsp&nbsp&nbsp&nbsp&nbsp <- tell SED where to cut when generating fixed package</TT><BR><TT></TT><BR><TT>&nbsp&nbsp ------------</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp OVERVIEW</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp This package provides a DBMS "pipe" service which allows messages</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp to be sent between sessions.</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp The metaphor is similar to UNIX pipes:&nbsp&nbsp you can do</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp dbms_pipe.send_message(<pipename>)</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp dbms_pipe.receive_message(<pipename>)</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp which will cause a message to be sent or received.&nbsp&nbsp You do</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp dbms_pipe.pack_message(<varchar2>|<number>|<date>)</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp to pack an item into a static buffer (which will then be sent with</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp the "send_message" call), and</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp dbms_pipe.unpack_message(<varchar2>|<number>|<date>)</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp to get an item out of the static buffer (which is filled by the</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp "receive_message" call).</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Pipes can be private to a user-id - which only allows session connected</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp under the same user-id or stored procedure owned by the user-id to read</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp write to the pipe.&nbsp&nbsp Pipes could be public - and all database users with</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp execute privilege on dbms_pipe and knowledge of the pipe can read or</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp write to the pipe.</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Pipes operate independently of transactions.&nbsp&nbsp They also operate</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp asynchronously.&nbsp&nbsp There can be multiple readers and writers of the</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp same pipe.</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Pipes only operate between sessions in the same instance.</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Pipes can be explicitly created using</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp dbms_pipe.create_pipe(<pipename>)</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp and removed using</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp dbms_pipe.remove_pipe(<pipename>)</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp A pipe created using the explicit create command should be removed</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp using the remove function.&nbsp&nbsp A pipe can also be created implicitly.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Pipes automatically come into existence the first time they are</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp referenced.&nbsp&nbsp They effectively disappear when they contain no more</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp data (some overhead remains in the SGA until it gets aged out).</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Pipes take up space in the SGA (see "maxpipesize" parameter to</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp "send_message").</TT><BR><TT></TT><BR><TT></TT><BR><TT>&nbsp&nbsp --------</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp USES</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp The pipe functionality has several potential applications:</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp o External service interface.&nbsp&nbsp You can provide the ability to</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp communicate with (user-written) services that are external to the</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RDBMS.&nbsp&nbsp This can be done in a (effectively) multi-threaded manner</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp so that several instances of the service can be executing</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp simultaneously. Additionally, the services are available</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp asynchronously - the requestor of the service need not block</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp awaiting a reply.&nbsp&nbsp The requestor can check (with or without</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp timeout) at a later time.&nbsp&nbsp The service can be written in any</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp of the 3GL languages that ORACLE supports, not just C.&nbsp&nbsp See</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp example below.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp o Independent transactions.&nbsp&nbsp The pipe can be used to communicate</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp to a separate session which can perform an operation in an</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp independent transaction (such as logging an attempted security</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp violation detected by a trigger).</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp o Alerters (non-transactional).&nbsp&nbsp You can post another process</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp without requiring the waiting process to poll.&nbsp&nbsp If an "after-row"</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp or "after-statement" trigger were to alert an application, then</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp the application would treat this alert as an indication that</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp the data probably changed.&nbsp&nbsp The application would then go read</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp the data to get the current value.&nbsp&nbsp Since this is an "after"</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp trigger, the application would want to do a "select for update"</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp to make sure it read the correct data.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp o Debugging.&nbsp&nbsp Triggers and/or stored procedures can send debugging</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp information to a pipe.&nbsp&nbsp Another session can keep reading out</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp of the pipe and displaying it on the screen or writing it</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp out to a file.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp o Concentrator. Useful for multiplexing large numbers of users</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp over a fewer number of network connections, or improving</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp performance by concentrating several user-transactions into</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp one dbms-transaction.</TT><BR><TT></TT><BR><TT></TT><BR><TT>&nbsp&nbsp ------------</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp SECURITY</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Security can be achieved by use of 'grant execute' on the dbms_pipe</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp package, by creating a pipe using the 'private' parameter in the create</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp function and by writing cover packages that only expose particular</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp features or pipenames to particular users or roles.</TT><BR><TT></TT><BR><TT></TT><BR><TT>&nbsp&nbsp ------------</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp EXAMPLES</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp External service interface</TT><BR><TT>&nbsp&nbsp ------------------------------</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Put the user-written 3GL code into an OCI or Precompiler program.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp The program connects to the database and executes PL/SQL code to read</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp its request from the pipe, computes the result, and then executes</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp PL/SQL code to send the result on a pipe back to the requestor.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Below is an example of a stock service request.</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp The recommended sequence for the arguments to pass on the pipe</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp for all service requests is</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp protocol_version&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp varchar2&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp - '1', 10 bytes or less</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp returnpipe&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp varchar2&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp - 30 bytes or less</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp service&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp varchar2&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp - 30 bytes or less</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp arg1&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp varchar2/number/date</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ...</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp argn&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp varchar2/number/date</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp The recommended format for returning the result is</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp success&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp varchar2&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp - 'SUCCESS' if OK,</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp otherwise error message</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp arg1&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp varchar2/number/date</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ...</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp argn&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp varchar2/number/date</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp The "stock price request server" would do, using OCI or PRO* (in</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp pseudo-code):</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp <loop forever></TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp begin dbms_stock_server.get_request(:stocksymbol); end;</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp <figure out price based on stocksymbol (probably from some radio</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp signal), set error if can't find such a stock></TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp begin dbms_stock_server.return_price(:error, :price); end;</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp A client would do:</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp begin :price := stock_request('YOURCOMPANY'); end;</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp The stored procedure, dbms_stock_server, which is called by the</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp "stock price request server" above is:</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp create or replace package dbms_stock_server is</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp procedure get_request(symbol out varchar2);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp procedure return_price(errormsg in varchar2, price in varchar2);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp end;</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp create&nbsp&nbsp or replace package body dbms_stock_server is</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp returnpipe&nbsp&nbsp&nbsp&nbsp varchar2(30);</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp procedure returnerror(reason varchar2) is</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp s integer;</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp begin</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp dbms_pipe.pack_message(reason);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp s := dbms_pipe.send_message(returnpipe);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if s <> 0 then</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp raise_application_error(-20000, 'Error:' || to_char(s) ||</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ' sending on pipe');</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp end if;</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp end;</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp procedure get_request(symbol out varchar2) is</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp protocol_version varchar2(10);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp s&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp integer;</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp service&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp varchar2(30);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp begin</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp s := dbms_pipe.receive_message('stock_service');</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if s <> 0 then</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp raise_application_error(-20000, 'Error:' || to_char(s) ||</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 'reading pipe');</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp end if;</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp dbms_pipe.unpack_message(protocol_version);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if protocol_version <> '1' then</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp raise_application_error(-20000, 'Bad protocol: ' ||</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp protocol_version);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp end if;</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp dbms_pipe.unpack_message(returnpipe);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp dbms_pipe.unpack_message(service);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if service != 'getprice' then</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp returnerror('Service ' || service || ' not supported');</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp end if;</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp dbms_pipe.unpack_message(symbol);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp end;</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp procedure return_price(errormsg in varchar2, price in varchar2) is</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp s integer;</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp begin</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if errormsg is null then</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp dbms_pipe.pack_message('SUCCESS');</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp dbms_pipe.pack_message(price);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp dbms_pipe.pack_message(errormsg);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp end if;</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp s := dbms_pipe.send_message(returnpipe);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if s <> 0 then</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp raise_application_error(-20000, 'Error:'||to_char(s)||</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ' sending on pipe');</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp end if;</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp end;</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp end;</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp The procedure called by the client is:</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp create or replace function stock_request (symbol varchar2)</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp return varchar2 is</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp s&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp integer;</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp price&nbsp&nbsp&nbsp&nbsp varchar2(20);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp errormsg varchar2(512);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp begin</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp dbms_pipe.pack_message('1');&nbsp&nbsp -- protocol version</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp dbms_pipe.pack_message(dbms_pipe.unique_session_name); -- return pipe</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp dbms_pipe.pack_message('getprice');</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp dbms_pipe.pack_message(symbol);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp s := dbms_pipe.send_message('stock_service');</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if s <> 0 then</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp raise_application_error(-20000, 'Error:'||to_char(s)||</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ' sending on pipe');</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp end if;</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp s := dbms_pipe.receive_message(dbms_pipe.unique_session_name);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if s <> 0 then</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp raise_application_error(-20000, 'Error:'||to_char(s)||</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ' receiving on pipe');</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp end if;</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp dbms_pipe.unpack_message(errormsg);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if errormsg <> 'SUCCESS' then</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp raise_application_error(-20000, errormsg);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp end if;</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp dbms_pipe.unpack_message(price);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp return price;</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp end;</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp You would typically only grant execute on 'dbms_stock_service' to</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp the stock service application server, and would only grant execute</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp on 'stock_request' to those users allowed to use the service.</TT><BR><TT></TT><BR><TT></TT><BR><TT>&nbsp&nbsp ---------------------</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp SPECIAL CONSTANTS</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp maxwait&nbsp&nbsp&nbsp constant integer := 86400000; /* 1000 days */</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp The maximum time to wait attempting to send or receive a message</TT><BR><TT></TT><BR><TT></TT><BR><TT>&nbsp&nbsp ----------------------------</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp PROCEDURES AND FUNCTIONS</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp procedure pack_message(item in varchar2 character set any_cs);</TT><BR><TT>&nbsp&nbsp pragma restrict_references(pack_message,WNDS,RNDS);</TT><BR><TT>&nbsp&nbsp procedure pack_message(item in number);</TT><BR><TT>&nbsp&nbsp pragma restrict_references(pack_message,WNDS,RNDS);</TT><BR><TT>&nbsp&nbsp procedure pack_message(item in date);</TT><BR><TT>&nbsp&nbsp pragma restrict_references(pack_message,WNDS,RNDS);</TT><BR><TT>&nbsp&nbsp procedure pack_message_raw(item in raw);</TT><BR><TT>&nbsp&nbsp pragma restrict_references(pack_message_raw,WNDS,RNDS);</TT><BR><TT>&nbsp&nbsp procedure pack_message_rowid(item in rowid);</TT><BR><TT>&nbsp&nbsp pragma restrict_references(pack_message_rowid,WNDS,RNDS);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Pack an item into the message buffer</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Input parameters:</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp item</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Item to pack into the local message buffer.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Exceptions:</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp ORA-06558 generated if message buffer overflows (currently 4096</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp bytes).&nbsp&nbsp Each item in the buffer takes one byte for the type,</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp two bytes for the length, plus the actual data.&nbsp&nbsp There is also one</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp byte needed to terminate the message.</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp procedure unpack_message(item out varchar2 character set any_cs);</TT><BR><TT>&nbsp&nbsp pragma restrict_references(unpack_message,WNDS,RNDS);</TT><BR><TT>&nbsp&nbsp procedure unpack_message(item out number);</TT><BR><TT>&nbsp&nbsp pragma restrict_references(unpack_message,WNDS,RNDS);</TT><BR><TT>&nbsp&nbsp procedure unpack_message(item out date);</TT><BR><TT>&nbsp&nbsp pragma restrict_references(unpack_message,WNDS,RNDS);</TT><BR><TT>&nbsp&nbsp procedure unpack_message_raw(item out raw);</TT><BR><TT>&nbsp&nbsp pragma restrict_references(unpack_message_raw,WNDS,RNDS);</TT><BR><TT>&nbsp&nbsp procedure unpack_message_rowid(item out rowid);</TT><BR><TT>&nbsp&nbsp pragma restrict_references(unpack_message_rowid,WNDS,RNDS);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Unpack an item from the local message buffer</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Output parameters:</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp item</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp The argument to receive the next unpacked item from the local</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp message buffer.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Exceptions:</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp ORA-06556 or 06559 are generated if the buffer contains</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp no more items, or if the item is not of the same type as that</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp requested (see 'next_item_type' below).</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp function next_item_type return integer;</TT><BR><TT>&nbsp&nbsp pragma restrict_references(next_item_type,WNDS,RNDS);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Get the type of the next item in the local message buffer</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Return value:</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp Type of next item in buffer:</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 0&nbsp&nbsp&nbsp&nbsp no more items</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 9&nbsp&nbsp&nbsp&nbsp varchar2</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 6&nbsp&nbsp&nbsp&nbsp number</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 11&nbsp&nbsp&nbsp&nbsp rowid</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 12&nbsp&nbsp&nbsp&nbsp date</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 23&nbsp&nbsp&nbsp&nbsp raw</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp function create_pipe(pipename in varchar2,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp maxpipesize in integer default 8192,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp private in boolean default TRUE,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp global in boolean default FALSE)</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp return integer;</TT><BR><TT>&nbsp&nbsp pragma restrict_references(create_pipe,WNDS,RNDS);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Create an empty pipe with the given name.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Input parameters:</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp pipename</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Name of pipe to be created.&nbsp&nbsp WARNING: Do not use pipe names</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp beginning with 'ORA$'.&nbsp&nbsp These are reserved for use by procedures</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp provided by Oracle Corporation.&nbsp&nbsp Pipename should not be longer than</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 128 bytes, and is case_insensitive.&nbsp&nbsp At this time, the name cannot</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp contain NLS characters.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp maxpipesize</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Maximum allowed size for the pipe.&nbsp&nbsp The total size of all the</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp messages on the pipe cannot exceed this amount.&nbsp&nbsp The maxpipesize</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp for a pipe becomes part of the pipe and persists for the lifetime</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp of the pipe.&nbsp&nbsp Callers of send_message with larger values will</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp cause the maxpipesize to be increased.&nbsp&nbsp Callers with a smaller</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp value will just use the larger value.&nbsp&nbsp The specification of</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp maxpipesize here allows us to avoid its use in future send_message</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp calls.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp private</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Boolean indicating whether the pipe will be private - and for the</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp use of the creating user-id, or public.&nbsp&nbsp A private pipe can be used</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp directly through calls to this package by sessions connected to the</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp database as the same user as the one that created the pipe.&nbsp&nbsp It can</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp also be used via stored procedures owned by the user that created</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp the pipe.&nbsp&nbsp The procedure may be executed by anyone with execute</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp privilege on it.&nbsp&nbsp A public pipe can be accessed by anyone who has</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp knowledge of it and execute privilege on dbms_pipe.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Return values:</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp 0 - Success.&nbsp&nbsp This is returned even if the pipe had been created in</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp mode that permits its use by the user executing the create call.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp If a pipe already existed, it is not emptied.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Exceptions:</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp Null pipe name.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp Permission error.&nbsp&nbsp Pipe with the same name already exists and</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp you are not allowed to use it.</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp function remove_pipe(pipename in varchar2)</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp return integer;</TT><BR><TT>&nbsp&nbsp pragma restrict_references(remove_pipe,WNDS,RNDS);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Remove the named pipe.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Input Parameters:</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp pipename</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Name of pipe to remove.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Return value:</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp 0 - Success. Calling remove on a pipe that does not exist returns 0.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Exceptions:</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp Null pipe name.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp Permission error.&nbsp&nbsp Insufficient privilege to remove pipe.&nbsp&nbsp The</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pipe was created and is owned by someone else.</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp function send_message(pipename in varchar2,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp timeout in integer default maxwait,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp maxpipesize in integer default 8192)</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp return integer;</TT><BR><TT>&nbsp&nbsp pragma restrict_references(send_message,WNDS,RNDS);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Send a message on the named pipe.&nbsp&nbsp The message is contained in the</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp local message buffer which was filled with calls to 'pack_message'.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp A pipe could have been created explicitly using 'create_pipe', or</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp it will be created implicitly.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Input parameters:</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp pipename</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Name of pipe to place the message on.&nbsp&nbsp The message is copied</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp from the local buffer which can be filled by the "pack_message"</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp routine.&nbsp&nbsp WARNING:&nbsp&nbsp Do not use pipe names beginning with 'ORA$'.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp These names are reserved for use by procedures provided by</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Oracle Corporation.&nbsp&nbsp Pipename should not be longer than 128 bytes,</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp and is case_insensitive.&nbsp&nbsp At this time, the name cannot</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp contain NLS characters.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp timeout</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Time to wait while attempting to place a message on a pipe, in</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp seconds (see return codes below).</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp maxpipesize</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Maximum allowed size for the pipe.&nbsp&nbsp The total size of all the</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp messages on the pipe cannot exceed this amount.&nbsp&nbsp If this message</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp would exceed this amount the call will block.&nbsp&nbsp The maxpipesize</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp for a pipe becomes part of the pipe and persists for the lifetime</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp of the pipe.&nbsp&nbsp Callers of send_message with larger values will</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp cause the maxpipesize to be increased.&nbsp&nbsp Callers with a smaller</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp value will just use the larger value.&nbsp&nbsp The specification of</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp maxpipesize here allows us to avoid the use of a "open_pipe" call.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Return value:</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp 0 - Success</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp 1 - Timed out (either because can't get lock on pipe or pipe stays</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp too full)</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp 3 - Interrupted</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Exceptions:</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp Null pipe name.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp Permission error.&nbsp&nbsp Insufficient privilege to write to the pipe.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp The pipe is private and owned by someone else.</TT><BR><TT>&nbsp&nbsp function receive_message(pipename in varchar2,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp timeout in integer default maxwait)</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp return integer;</TT><BR><TT>&nbsp&nbsp pragma restrict_references(receive_message,WNDS,RNDS);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Receive a message from the named pipe.&nbsp&nbsp Copy the message into the</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp local message buffer.&nbsp&nbsp Use 'unpack_message' to access the</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp individual items in the message.&nbsp&nbsp The pipe can be created explicitly</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp using the 'create_pipe' function or it will be created implicitly.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Input parameters:</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp pipename</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Name of pipe from which to retrieve a message.&nbsp&nbsp The message is</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp copied into a local buffer which can be accessed by the</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp "unpack_message" routine.&nbsp&nbsp WARNING:&nbsp&nbsp Do not use pipe names</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp beginning with 'ORA$'.&nbsp&nbsp These names are reserved for use by</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp procedures provided by Oracle Corporation. Pipename should not be</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp longer than 128 bytes, and is case-insensitive.&nbsp&nbsp At this time,</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp the name cannot contain NLS characters.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp timeout</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Time to wait for a message.&nbsp&nbsp A timeout of 0 allows you to read</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp without blocking.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Return value:</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp 0 - Success</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp 1 - Timed out</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp 2 - Record in pipe too big for buffer (should not happen).</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp 3 - Interrupted</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Exceptions:</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp Null pipe name.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp Permission error.&nbsp&nbsp Insufficient privilege to remove the record</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp from the pipe.&nbsp&nbsp The pipe is owned by someone else.</TT><BR><TT>&nbsp&nbsp procedure reset_buffer;</TT><BR><TT>&nbsp&nbsp pragma restrict_references(reset_buffer,WNDS,RNDS);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Reset pack and unpack positioning indicators to 0.&nbsp&nbsp Generally this</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp routine is not needed.</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp procedure purge(pipename in varchar2);</TT><BR><TT>&nbsp&nbsp pragma restrict_references(purge,WNDS,RNDS);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Empty out the named pipe.&nbsp&nbsp An empty pipe is a candidate for LRU</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp removal from the SGA, therefore 'purge' can be used to free all</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp memory associated with a pipe.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Input Parameters:</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp pipename</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Name of pipe from which to remove all messages.&nbsp&nbsp The local</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp buffer may be overwritten with messages as they are discarded.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Pipename should not be longer than 128 bytes, and is</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case-insensitive.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Exceptions:</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp Permission error if pipe belongs to another user.</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp function unique_session_name return varchar2;</TT><BR><TT>&nbsp&nbsp pragma restrict_references(unique_session_name,WNDS,RNDS,WNPS);</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Get a name that is unique among all sessions currently connected</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp to this database.&nbsp&nbsp Multiple calls to this routine from the same</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp session will always return the same value.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Return value:</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp A unique name.&nbsp&nbsp The returned name can be up to 30 bytes.</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT></TT><BR><TT>&nbsp&nbsp pragma TIMESTAMP('2000-06-09:14:30:00');</TT><BR><TT></TT><BR><TT>end;</TT><BR><TT></TT><BR><TT>-- CUT_HERE&nbsp&nbsp&nbsp&nbsp <- tell sed where to chop off the rest</TT>&nbsp;</TT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Body SQL&nbsp;</FONT></B></TD>
<TD><TT>&nbsp;</TT></TD>
</TR>
</TABLE>
<P>
<TABLE WIDTH=100% CELLPADDING=3 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="LIGHTGREY" ><B><FONT SIZE=4 FACE="Arial">DBMS_PIPE Object Permissions&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">User/Role Name&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Grantee Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Permission Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Action Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Is Action Extended&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Is System&nbsp;</FONT></B></TD>
</TR>
<P>
<TABLE WIDTH=100% CELLPADDING=3 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="LIGHTGREY" ><B><FONT SIZE=4 FACE="Arial">DBMS_PIPE Bound Attachments&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP  WIDTH=30% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Name&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=46% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Current Value&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<HR>
<A NAME = "Pack_41edce3cf3c04f22a710a3b502d2248b"></A>
<TABLE WIDTH=100% CELLPADDING=1 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="darkblue" ><B><FONT SIZE=5 COLOR="white" FACE="Arial">DBMS_RANDOM&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Owner&nbsp;</FONT></B></TD>
<TD><FONT SIZE=2 FACE="Arial">SYS&nbsp;</FONT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Description&nbsp;</FONT></B></TD>
<TD><FONT SIZE=2 FACE="Arial">&nbsp;</FONT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Header SQL&nbsp;</FONT></B></TD>
<TD><TT><TT>CREATE OR REPLACE PACKAGE SYS.dbms_random AUTHID DEFINER AS</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp ------------</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp OVERVIEW</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp This package should be installed as SYS.&nbsp&nbsp It generates a sequence of</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp random 38-digit Oracle numbers.&nbsp&nbsp The expected length of the sequence</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp is about power(10,28), which is hopefully long enough.</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --------</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp USAGE</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp This is a random number generator.&nbsp&nbsp Do not use for cryptography.</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp For more options the cryptographic toolkit should be used.</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp By default, the package is initialized with the current user</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp name, current time down to the second, and the current session.</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp If this package is seeded twice with the same seed, then accessed</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp in the same way, it will produce the same results in both cases.</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --------</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp EXAMPLES</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp To initialize or reset the generator, call the seed procedure as in:</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp execute dbms_random.seed(12345678);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp or</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp execute dbms_random.seed(TO_CHAR(SYSDATE,'MM-DD-YYYY HH24:MI:SS'));</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp To get the random number, simply call the function, e.g.</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp my_random_number BINARY_INTEGER;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp my_random_number := dbms_random.random;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp or</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp my_random_real NUMBER;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp my_random_real := dbms_random.value;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp To use in SQL statements:</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp select dbms_random.value from dual;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp insert into a values (dbms_random.value);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp variable x NUMBER;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp execute :x := dbms_random.value;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp update a set a2=a2+1 where a1 < :x;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp -- Seed with a binary integer</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp PROCEDURE seed(val IN BINARY_INTEGER);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp PRAGMA restrict_references (seed, WNDS);</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp -- Seed with a string (up to length 2000)</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp PROCEDURE seed(val IN VARCHAR2);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp PRAGMA restrict_references (seed, WNDS);</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp -- Get a random 38-digit precision number, 0.0 <= value < 1.0</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp FUNCTION value RETURN NUMBER PARALLEL_ENABLE;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp PRAGMA restrict_references (value, WNDS);</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp -- get a random Oracle number x, low <= x < high</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp FUNCTION value (low IN NUMBER, high IN NUMBER) RETURN NUMBER</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp PARALLEL_ENABLE;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp PRAGMA restrict_references (value, WNDS);</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp -- get a random number from a normal distribution</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp FUNCTION normal RETURN NUMBER PARALLEL_ENABLE;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp PRAGMA restrict_references (normal, WNDS);</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp -- get a random string</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp FUNCTION string (opt char, len NUMBER)</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /* "opt" specifies that the returned string may contain:</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 'u','U'&nbsp&nbsp :&nbsp&nbsp upper case alpha characters only</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 'l','L'&nbsp&nbsp :&nbsp&nbsp lower case alpha characters only</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 'a','A'&nbsp&nbsp :&nbsp&nbsp alpha characters only (mixed case)</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 'x','X'&nbsp&nbsp :&nbsp&nbsp any alpha-numeric characters (upper)</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 'p','P'&nbsp&nbsp :&nbsp&nbsp any printable characters</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp */</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN VARCHAR2 PARALLEL_ENABLE;&nbsp&nbsp -- string of <len> characters</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp PRAGMA restrict_references (string, WNDS);</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp -- Obsolete, just calls seed(val)</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp PROCEDURE initialize(val IN BINARY_INTEGER);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp PRAGMA restrict_references (initialize, WNDS);</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp -- Obsolete, get integer in ( -power(2,31) <= random < power(2,31) )</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp FUNCTION random RETURN BINARY_INTEGER PARALLEL_ENABLE;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp PRAGMA restrict_references (random, WNDS);</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp -- Obsolete, does nothing</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp PROCEDURE terminate;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp TYPE num_array IS TABLE OF NUMBER INDEX BY BINARY_INTEGER;</TT><BR><TT>END dbms_random;</TT>&nbsp;</TT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Body SQL&nbsp;</FONT></B></TD>
<TD><TT><TT>CREATE OR REPLACE PACKAGE BODY SYS.dbms_random AS</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp mem&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp num_array;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp -- big internal state hidden from the user</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp counter&nbsp&nbsp&nbsp&nbsp BINARY_INTEGER := 55;-- counter through the results</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp saved_norm NUMBER := NULL;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp -- unused random normally distributed value</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp need_init&nbsp&nbsp BOOLEAN := TRUE;&nbsp&nbsp&nbsp&nbsp&nbsp -- do we still need to initialize</TT><BR><TT></TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp -- Seed the random number generator with a binary_integer</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp PROCEDURE seed(val IN BINARY_INTEGER) IS</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp BEGIN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp seed(TO_CHAR(val));</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp END seed;</TT><BR><TT></TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp -- Seed the random number generator with a string.</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp PROCEDURE seed(val IN VARCHAR2) IS</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp junk&nbsp&nbsp&nbsp&nbsp&nbsp VARCHAR2(2000);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp piece&nbsp&nbsp&nbsp&nbsp VARCHAR2(20);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp randval&nbsp&nbsp NUMBER;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp mytemp&nbsp&nbsp&nbsp NUMBER;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp j&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp BINARY_INTEGER;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp BEGIN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp need_init&nbsp&nbsp&nbsp := FALSE;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp saved_norm&nbsp&nbsp := NULL;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp counter&nbsp&nbsp&nbsp&nbsp&nbsp := 0;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp junk&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp := TO_SINGLE_BYTE(val);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp FOR i IN 0..54 LOOP</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp piece&nbsp&nbsp&nbsp := SUBSTR(junk,1,19);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp randval := 0;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp j&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp := 1;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp -- convert 19 characters to a 38-digit number</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp FOR j IN 1..19 LOOP</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp randval := 1e2*randval + NVL(ASCII(SUBSTR(piece,j,1)),0.0);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END LOOP;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp -- try to avoid lots of zeros</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp randval := randval*1e-38+i*.01020304050607080910111213141516171819;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp mem(i)&nbsp&nbsp := randval - TRUNC(randval);</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp -- we've handled these first 19 characters already; move on</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp junk&nbsp&nbsp&nbsp&nbsp := SUBSTR(junk,20);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END LOOP;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp randval := mem(54);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp FOR j IN 0..10 LOOP</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp FOR i IN 0..54 LOOP</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp -- barrelshift mem(i-1) by 24 digits</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp randval := randval * 1e24;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp mytemp&nbsp&nbsp := TRUNC(randval);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp randval := (randval - mytemp) + (mytemp * 1e-38);</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp -- add it to mem(i)</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp randval := mem(i)+randval;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IF (randval >= 1.0) THEN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp randval := randval - 1.0;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END IF;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp -- record the result</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp mem(i) := randval;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END LOOP;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END LOOP;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp END seed;</TT><BR><TT></TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp -- give values to the user</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp -- Delayed Fibonacci, pilfered from Knuth volume 2</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp FUNCTION value RETURN NUMBER&nbsp&nbsp PARALLEL_ENABLE IS</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp randval&nbsp&nbsp NUMBER;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp BEGIN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp counter := counter + 1;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IF counter >= 55 THEN</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp -- initialize if needed</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IF (need_init = TRUE) THEN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp seed(TO_CHAR(SYSDATE,'MM-DD-YYYY HH24:MI:SS') ||</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USER || USERENV('SESSIONID'));</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ELSE</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp -- need to generate 55 more results</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp FOR i IN 0..30 LOOP</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp randval := mem(i+24) + mem(i);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IF (randval >= 1.0) THEN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp randval := randval - 1.0;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END IF;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp mem(i) := randval;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END LOOP;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp FOR i IN 31..54 LOOP</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp randval := mem(i-31) + mem(i);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IF (randval >= 1.0) THEN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp randval := randval - 1.0;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END IF;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp mem(i) := randval;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END LOOP;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END IF;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp counter := 0;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END IF;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN mem(counter);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp END value;</TT><BR><TT></TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp -- Random 38-digit number between LOW and HIGH.</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp FUNCTION value ( low in NUMBER, high in NUMBER) RETURN NUMBER</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp PARALLEL_ENABLE is</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp BEGIN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN (value*(high-low))+low;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp END value;</TT><BR><TT></TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp -- Random numbers in a normal distribution.</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp -- Pilfered from Knuth volume 2.</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp FUNCTION normal RETURN NUMBER PARALLEL_ENABLE is</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp -- 38 decimal places: Mean 0, Variance 1</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp v1&nbsp&nbsp NUMBER;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp v2&nbsp&nbsp NUMBER;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp r2&nbsp&nbsp NUMBER;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp fac NUMBER;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp BEGIN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IF saved_norm is not NULL THEN&nbsp&nbsp&nbsp&nbsp&nbsp -- saved from last time</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp v1 := saved_norm;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp -- to be returned this time</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp saved_norm := NULL;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ELSE</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp r2 := 2;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp -- Find two independent uniform variables</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp WHILE r2 > 1 OR r2 = 0 LOOP</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp v1 := value();</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp v1 := v1 + v1 - 1;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp v2 := value();</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp v2 := v2 + v2 - 1;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp r2 := v1*v1 + v2*v2;&nbsp&nbsp -- r2 is radius</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END LOOP;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp -- 0 < r2 <= 1:&nbsp&nbsp in unit circle</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /* Now derive two independent normally-distributed variables */</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp fac := sqrt(-2*ln(r2)/r2);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp v1 := v1*fac;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp -- to be returned this time</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp saved_norm := v2*fac;&nbsp&nbsp -- to be saved for next time</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END IF;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN v1;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp END&nbsp&nbsp normal;</TT><BR><TT></TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp -- Random string.&nbsp&nbsp Pilfered from Chris Ellis.</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp FUNCTION string (opt char, len NUMBER)</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN VARCHAR2 PARALLEL_ENABLE is&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp -- string of <len> characters</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp optx char (1)&nbsp&nbsp := lower(opt);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp rng&nbsp&nbsp NUMBER;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp n&nbsp&nbsp&nbsp&nbsp BINARY_INTEGER;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ccs&nbsp&nbsp VARCHAR2 (128);&nbsp&nbsp&nbsp&nbsp -- candidate character subset</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp xstr VARCHAR2 (4000) := NULL;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp BEGIN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IF&nbsp&nbsp&nbsp&nbsp optx = 'u' THEN&nbsp&nbsp&nbsp&nbsp -- upper case alpha characters only</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ccs := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp rng := 26;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ELSIF optx = 'l' THEN&nbsp&nbsp&nbsp&nbsp -- lower case alpha characters only</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ccs := 'abcdefghijklmnopqrstuvwxyz';</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp rng := 26;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ELSIF optx = 'a' THEN&nbsp&nbsp&nbsp&nbsp -- alpha characters only (mixed case)</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ccs := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' ||</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 'abcdefghijklmnopqrstuvwxyz';</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp rng := 52;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ELSIF optx = 'x' THEN&nbsp&nbsp&nbsp&nbsp -- any alpha-numeric characters (upper)</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ccs := '0123456789' ||</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp rng := 36;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ELSIF optx = 'p' THEN&nbsp&nbsp&nbsp&nbsp -- any printable char (ASCII subset)</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ccs := ' !"#$%&''()*+,-./' || '0123456789' || ':;<=>?@' ||</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' || '[\]^_`' ||</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 'abcdefghijklmnopqrstuvwxyz' || '{|}~' ;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp rng := 95;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ELSE</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ccs := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp rng := 26;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp -- default to upper case</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END IF;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp FOR i IN 1 .. least(len,4000) LOOP</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /* Get random integer within specified range */</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp n := TRUNC(rng * value) + 1;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /* Append character to string&nbsp&nbsp */</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp xstr := xstr || SUBSTR(ccs,n,1);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END LOOP;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN xstr;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp END string;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp -- For compatibility with 8.1</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp PROCEDURE initialize(val IN BINARY_INTEGER) IS</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp BEGIN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp seed(to_char(val));</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp END initialize;</TT><BR><TT></TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp -- For compatibility with 8.1</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp -- Random binary_integer, -power(2,31) <= Random < power(2,31)</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp -- Delayed Fibonacci, pilfered from Knuth volume 2</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp FUNCTION random RETURN BINARY_INTEGER PARALLEL_ENABLE IS</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp BEGIN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp RETURN TRUNC(Value*4294967296)-2147483648;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp END random;</TT><BR><TT></TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp -- For compatibility with 8.1</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp PROCEDURE terminate IS</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp BEGIN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp NULL;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp END terminate;</TT><BR><TT></TT><BR><TT>END dbms_random;</TT>&nbsp;</TT></TD>
</TR>
</TABLE>
<P>
<TABLE WIDTH=100% CELLPADDING=3 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="LIGHTGREY" ><B><FONT SIZE=4 FACE="Arial">DBMS_RANDOM Object Permissions&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">User/Role Name&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Grantee Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Permission Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Action Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Is Action Extended&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Is System&nbsp;</FONT></B></TD>
</TR>
<P>
<TABLE WIDTH=100% CELLPADDING=3 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="LIGHTGREY" ><B><FONT SIZE=4 FACE="Arial">DBMS_RANDOM Bound Attachments&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP  WIDTH=30% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Name&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=46% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Current Value&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<HR>
<A NAME = "Pack_7b7023ce3d1942bfa8947c1aca5a5466"></A>
<TABLE WIDTH=100% CELLPADDING=1 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="darkblue" ><B><FONT SIZE=5 COLOR="white" FACE="Arial">DBMS_SYS_ERROR&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Owner&nbsp;</FONT></B></TD>
<TD><FONT SIZE=2 FACE="Arial">SYS&nbsp;</FONT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Description&nbsp;</FONT></B></TD>
<TD><FONT SIZE=2 FACE="Arial">&nbsp;</FONT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Header SQL&nbsp;</FONT></B></TD>
<TD><TT><TT>CREATE OR REPLACE PACKAGE SYS.dbms_sys_error wrapped</TT><BR><TT>a000000</TT><BR><TT>1</TT><BR><TT>abcd</TT><BR><TT>abcd</TT><BR><TT>abcd</TT><BR><TT>abcd</TT><BR><TT>abcd</TT><BR><TT>abcd</TT><BR><TT>abcd</TT><BR><TT>abcd</TT><BR><TT>abcd</TT><BR><TT>abcd</TT><BR><TT>abcd</TT><BR><TT>abcd</TT><BR><TT>abcd</TT><BR><TT>abcd</TT><BR><TT>abcd</TT><BR><TT>9</TT><BR><TT>f5e 191</TT><BR><TT>xn6ZcFPanswNS1Y7ft3cTR+DN7Iwg83xrgxqZy+VAP5eRzvzCVor9gUw7Bu3UyExVgP9DK6Z</TT><BR><TT>UYDz8beaGS7zPlTb1jwkinanVWq7f/gZ63UgS2ZTnRJ2aKV6Uwe8qvw17PQsptd53OnGNl8l</TT><BR><TT>yILaCyZS22jAGkU5y8lilJv/oQEmZkpJpQh+49KHxlSdHdgFYRvDaWn0THlr24NQOoE/W9ir</TT><BR><TT>NhsLk4s8f43bGsBls/hjBjvFWUeGLVwjNN5O5Zt5JDXiJdbBYsA/1lasHU/uori5if9CuWZX</TT><BR><TT>+R92/mgBWvwkSUO+QlpXFM+JmJ7X59fORckwSPOrlKuBTvCbaJuxeAiFNL26MTDefvUhLuoK</TT><BR><TT>lVaT/0aFJUIb8Vah6O8u5QQq/4emH5qyMA==</TT>&nbsp;</TT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Body SQL&nbsp;</FONT></B></TD>
<TD><TT>&nbsp;</TT></TD>
</TR>
</TABLE>
<P>
<TABLE WIDTH=100% CELLPADDING=3 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="LIGHTGREY" ><B><FONT SIZE=4 FACE="Arial">DBMS_SYS_ERROR Object Permissions&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">User/Role Name&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Grantee Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Permission Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Action Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Is Action Extended&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Is System&nbsp;</FONT></B></TD>
</TR>
<P>
<TABLE WIDTH=100% CELLPADDING=3 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="LIGHTGREY" ><B><FONT SIZE=4 FACE="Arial">DBMS_SYS_ERROR Bound Attachments&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP  WIDTH=30% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Name&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=46% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Current Value&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<HR>
<A NAME = "Pack_b460b6f036444e5cb20aba5bccb949c2"></A>
<TABLE WIDTH=100% CELLPADDING=1 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="darkblue" ><B><FONT SIZE=5 COLOR="white" FACE="Arial">PL_MAU&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Owner&nbsp;</FONT></B></TD>
<TD><FONT SIZE=2 FACE="Arial">BNSTAGE&nbsp;</FONT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Description&nbsp;</FONT></B></TD>
<TD><FONT SIZE=2 FACE="Arial">&nbsp;</FONT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Header SQL&nbsp;</FONT></B></TD>
<TD><TT><TT>CREATE OR REPLACE PACKAGE BNSTAGE.PL_MAU AS</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp FUNCTION PL_Fetch_Most_Accessible_Unit (&nbsp&nbsp&nbsp&nbsp i_shipper&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IN&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.SHPR_NAME%TYPE,&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /* Requested shipper */</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp i_size_code&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IN&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.SIZE_CODE%TYPE,&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /* Requested size code */</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp o_unit_init&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp OUT&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.UNIT_INIT%TYPE,&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /* MAU init */</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp o_unit_num&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp OUT&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.UNIT_NBR%TYPE,&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /* MAU num */</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp o_lot_area_index&nbsp&nbsp&nbsp&nbsp&nbsp OUT&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.LOT_AREA_INDX%TYPE,&nbsp&nbsp /* MAU lot/area */</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp o_slot&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp OUT&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.SLOT_NBR%TYPE,&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /* MAU slot */</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp io_done&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IN OUT&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp INTEGER )&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /* fetch status flag */</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN INTEGER;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp FUNCTION PL_MAU_Units_Above (&nbsp&nbsp i_unit_init&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IN&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.UNIT_INIT%TYPE,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp i_unit_num&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IN&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.UNIT_NBR%TYPE )</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN INTEGER;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp FUNCTION PL_Close_Most_Accessible_Unit RETURN INTEGER;</TT><BR><TT></TT><BR><TT>END PL_MAU;</TT>&nbsp;</TT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Body SQL&nbsp;</FONT></B></TD>
<TD><TT><TT>CREATE OR REPLACE PACKAGE BODY BNSTAGE.PL_MAU AS</TT><BR><TT></TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp CURSOR GET_MAUS (&nbsp&nbsp&nbsp i_shipper&nbsp&nbsp UNITS.SHPR_NAME%TYPE,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp i_size_code&nbsp&nbsp&nbsp UNITS.SIZE_CODE%TYPE&nbsp&nbsp&nbsp&nbsp ) IS</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp SELECT unit_init, unit_nbr, lot_area_indx, slot_nbr FROM UNITS u WHERE</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (SHPR_NAME = i_shipper AND SIZE_CODE = i_size_code AND</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp MTY_IND = 1 AND</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp BOOKING_ID = ' ' AND</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 0 = ( select count(*) from stop s where s.unit_init = u.unit_init and s.unit_nbr = u.unit_nbr ) AND</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ( HOLD_IND IS NULL OR HOLD_IND != 1 ) AND</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ( OTBD_IND = 0 OR SUBSTR(DEST_NAME, 1, 9) = 'POOL&nbsp&nbsp&nbsp&nbsp&nbsp ' ) AND</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp LOT_AREA_INDX != 3 )</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ORDER BY</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp DECODE( MONT_STAK_IND, 'M', 0, 1 ),</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp PL_MAU.PL_MAU_Units_Above(unit_init, unit_nbr),</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp DBMS_RANDOM.VALUE;</TT><BR><TT></TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp /* Begin fetch function to get the most accessible units for a shipper and size code */</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp FUNCTION PL_Fetch_Most_Accessible_Unit (&nbsp&nbsp&nbsp&nbsp i_shipper&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IN&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.SHPR_NAME%TYPE,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp i_size_code&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IN&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.SIZE_CODE%TYPE,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp o_unit_init&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp OUT&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.UNIT_INIT%TYPE,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp o_unit_num&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp OUT&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.UNIT_NBR%TYPE,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp o_lot_area_index&nbsp&nbsp&nbsp&nbsp&nbsp OUT&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.LOT_AREA_INDX%TYPE,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp o_slot&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp OUT&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.SLOT_NBR%TYPE,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp io_done&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IN OUT&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp INTEGER )</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN INTEGER AS</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp status INTEGER;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp BEGIN</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp status := 0;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IF NOT GET_MAUS%isopen THEN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp OPEN GET_MAUS(i_shipper, i_size_code);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END IF;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp io_done := 0;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp FETCH GET_MAUS INTO o_unit_init, o_unit_num, o_lot_area_index, o_slot;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IF GET_MAUS%notfound THEN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp io_done := 1;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp CLOSE GET_MAUS;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ROLLBACK;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp status := -2;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN( status );</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END IF;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN ( status );</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp EXCEPTION</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp WHEN OTHERS THEN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp status := SQLCODE;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp CLOSE GET_MAUS;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ROLLBACK;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN ( status );</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp END PL_Fetch_Most_Accessible_Unit;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp FUNCTION PL_MAU_Units_Above(&nbsp&nbsp&nbsp&nbsp i_unit_init&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IN&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.UNIT_INIT%TYPE,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp i_unit_num&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IN&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.UNIT_NBR%TYPE )</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN INTEGER AS</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp l_count&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp INTEGER;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp l_init&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp CHAR(4);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp l_num&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp NUMBER;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp BEGIN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp l_count := 0;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp l_init := i_unit_init;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp l_num := i_unit_num;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp LOOP</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp BEGIN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /* ASSUMPTION -- only one unit stacked on top of a given unit */</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp SELECT unit_1_init, unit_1_nbr INTO l_init, l_num FROM adjacency WHERE</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (unit_2_init = l_init AND unit_2_nbr = l_num AND direction = 20 AND ROWNUM = 1);</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp l_count := l_count + 1;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp EXCEPTION</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp WHEN OTHERS THEN EXIT;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END LOOP;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN ( l_count );</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp EXCEPTION</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp WHEN OTHERS THEN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp l_count := SQLCODE;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN ( l_count );</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END PL_MAU_Units_Above;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp FUNCTION PL_Close_Most_Accessible_Unit</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN INTEGER AS</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp status INTEGER;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp BEGIN</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp status := 0;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IF GET_MAUS%isopen THEN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp CLOSE GET_MAUS;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END IF;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN ( status );</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp EXCEPTION</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp WHEN OTHERS THEN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp status := SQLCODE;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ROLLBACK;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN ( status );</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp END PL_Close_Most_Accessible_Unit;</TT><BR><TT></TT><BR><TT>END PL_MAU;</TT>&nbsp;</TT></TD>
</TR>
</TABLE>
<P>
<TABLE WIDTH=100% CELLPADDING=3 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="LIGHTGREY" ><B><FONT SIZE=4 FACE="Arial">PL_MAU Object Permissions&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">User/Role Name&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Grantee Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Permission Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Action Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Is Action Extended&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Is System&nbsp;</FONT></B></TD>
</TR>
<P>
<TABLE WIDTH=100% CELLPADDING=3 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="LIGHTGREY" ><B><FONT SIZE=4 FACE="Arial">PL_MAU Bound Attachments&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP  WIDTH=30% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Name&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=46% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Current Value&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<HR>
<A NAME = "Pack_7a5a8be18dde488c8ca4a4ecc4720d2b"></A>
<TABLE WIDTH=100% CELLPADDING=1 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="darkblue" ><B><FONT SIZE=5 COLOR="white" FACE="Arial">PL_UNIT_MATES&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Owner&nbsp;</FONT></B></TD>
<TD><FONT SIZE=2 FACE="Arial">BNSTAGE&nbsp;</FONT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Description&nbsp;</FONT></B></TD>
<TD><FONT SIZE=2 FACE="Arial">&nbsp;</FONT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Header SQL&nbsp;</FONT></B></TD>
<TD><TT><TT>CREATE OR REPLACE PACKAGE BNSTAGE.PL_Unit_Mates AS</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp FUNCTION PL_Fetch_Unit_Mates (&nbsp&nbsp i_chassis_init&nbsp&nbsp&nbsp IN&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.UNIT_INIT%TYPE,&nbsp&nbsp&nbsp&nbsp&nbsp /* chassis initial */</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp i_chassis_num&nbsp&nbsp&nbsp&nbsp IN&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.UNIT_NBR%TYPE,&nbsp&nbsp&nbsp&nbsp&nbsp /* chassis number */</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp o_mate_init&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp OUT&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.UNIT_INIT%TYPE,&nbsp&nbsp&nbsp&nbsp&nbsp /* container initial */</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp o_mate_num&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp OUT&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.UNIT_NBR%TYPE,&nbsp&nbsp&nbsp&nbsp&nbsp /* container number */</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp io_done&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IN OUT&nbsp&nbsp&nbsp&nbsp&nbsp INTEGER )&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /* fetch status flag */</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN INTEGER;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp FUNCTION PL_Close_Get_Mates RETURN INTEGER;</TT><BR><TT></TT><BR><TT>END PL_Unit_Mates;</TT>&nbsp;</TT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Body SQL&nbsp;</FONT></B></TD>
<TD><TT><TT>CREATE OR REPLACE PACKAGE BODY BNSTAGE.PL_Unit_Mates AS</TT><BR><TT></TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp /* Declare mates cursor */</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp CURSOR GET_MATES (&nbsp&nbsp i_chassis_init&nbsp&nbsp UNITS.UNIT_INIT%TYPE,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp i_chassis_num&nbsp&nbsp&nbsp UNITS.UNIT_NBR%TYPE&nbsp&nbsp&nbsp&nbsp ) IS</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp SELECT UNIT_1_INIT, UNIT_1_NBR FROM UNITS, ADJACENCY WHERE</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (UNIT_2_INIT = i_chassis_init) AND (UNIT_2_NBR = i_chassis_num) AND</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UNIT_INIT=UNIT_1_INIT AND UNIT_NBR=UNIT_1_NBR AND</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (DIRECTION = 20) AND (MONT_STAK_IND = 'M');</TT><BR><TT></TT><BR><TT></TT><BR><TT></TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp /* Begin fetch function to get the mates for a chassis */</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp FUNCTION PL_Fetch_Unit_Mates (&nbsp&nbsp i_chassis_init&nbsp&nbsp&nbsp IN&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.UNIT_INIT%TYPE,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp i_chassis_num&nbsp&nbsp&nbsp&nbsp IN&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.UNIT_NBR%TYPE,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp o_mate_init&nbsp&nbsp&nbsp&nbsp&nbsp OUT&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.UNIT_INIT%TYPE,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp o_mate_num&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp OUT&nbsp&nbsp&nbsp&nbsp&nbsp UNITS.UNIT_NBR%TYPE,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp io_done&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IN OUT&nbsp&nbsp&nbsp&nbsp&nbsp INTEGER )</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN INTEGER AS</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp status INTEGER;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp BEGIN</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp status := 0;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IF NOT GET_MATES%isopen THEN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp OPEN GET_MATES(i_chassis_init, i_chassis_num);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END IF;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp io_done := 0;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp FETCH GET_MATES INTO o_mate_init, o_mate_num;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IF GET_MATES%notfound THEN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp io_done := 1;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp CLOSE GET_MATES;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ROLLBACK;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp status := -2;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN( status );</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END IF;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN ( status );</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp EXCEPTION</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp WHEN OTHERS THEN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp status := SQLCODE;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp CLOSE GET_MATES;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ROLLBACK;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN ( status );</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp END PL_Fetch_Unit_Mates;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp FUNCTION PL_Close_Get_Mates</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN INTEGER AS</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp status INTEGER;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp BEGIN</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp status := 0;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IF GET_MATES%isopen THEN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp CLOSE GET_MATES;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp END IF;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN ( status );</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp EXCEPTION</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp WHEN OTHERS THEN</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp status := SQLCODE;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ROLLBACK;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RETURN ( status );</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp END PL_Close_Get_Mates;</TT><BR><TT></TT><BR><TT>END PL_Unit_Mates;</TT>&nbsp;</TT></TD>
</TR>
</TABLE>
<P>
<TABLE WIDTH=100% CELLPADDING=3 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="LIGHTGREY" ><B><FONT SIZE=4 FACE="Arial">PL_UNIT_MATES Object Permissions&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">User/Role Name&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Grantee Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Permission Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Action Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Is Action Extended&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Is System&nbsp;</FONT></B></TD>
</TR>
<P>
<TABLE WIDTH=100% CELLPADDING=3 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="LIGHTGREY" ><B><FONT SIZE=4 FACE="Arial">PL_UNIT_MATES Bound Attachments&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP  WIDTH=30% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Name&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=46% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Current Value&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<HR>
<A NAME = "Pack_32c774bd52e04a3ebd2e9094f80c922f"></A>
<TABLE WIDTH=100% CELLPADDING=1 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="darkblue" ><B><FONT SIZE=5 COLOR="white" FACE="Arial">PL_VANTAGE_ENQUEUE&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Owner&nbsp;</FONT></B></TD>
<TD><FONT SIZE=2 FACE="Arial">BNSTAGE&nbsp;</FONT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Description&nbsp;</FONT></B></TD>
<TD><FONT SIZE=2 FACE="Arial">&nbsp;</FONT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Header SQL&nbsp;</FONT></B></TD>
<TD><TT><TT>CREATE OR REPLACE package BNSTAGE.PL_Vantage_Enqueue as</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp procedure put(info varchar2);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp end;</TT>&nbsp;</TT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Body SQL&nbsp;</FONT></B></TD>
<TD><TT><TT>CREATE OR REPLACE package body BNSTAGE.PL_Vantage_Enqueue as</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp procedure put(info varchar2) is</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp status integer;&nbsp&nbsp -- ret. val. required for the</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp begin</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp sys.dbms_pipe.pack_message(info);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp status := sys.dbms_pipe.send_message('VANTAGE_PIPE',0, 4000000);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp end;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp end;</TT>&nbsp;</TT></TD>
</TR>
</TABLE>
<P>
<TABLE WIDTH=100% CELLPADDING=3 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="LIGHTGREY" ><B><FONT SIZE=4 FACE="Arial">PL_VANTAGE_ENQUEUE Object Permissions&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">User/Role Name&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Grantee Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Permission Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Action Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Is Action Extended&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Is System&nbsp;</FONT></B></TD>
</TR>
<P>
<TABLE WIDTH=100% CELLPADDING=3 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="LIGHTGREY" ><B><FONT SIZE=4 FACE="Arial">PL_VANTAGE_ENQUEUE Bound Attachments&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP  WIDTH=30% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Name&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=46% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Current Value&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<HR>
<A NAME = "Pack_d57487e1c7f546dd8b6973d527eea437"></A>
<TABLE WIDTH=100% CELLPADDING=1 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="darkblue" ><B><FONT SIZE=5 COLOR="white" FACE="Arial">PLSDBG&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Owner&nbsp;</FONT></B></TD>
<TD><FONT SIZE=2 FACE="Arial">BNSTAGE&nbsp;</FONT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Description&nbsp;</FONT></B></TD>
<TD><FONT SIZE=2 FACE="Arial">&nbsp;</FONT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Header SQL&nbsp;</FONT></B></TD>
<TD><TT><TT>CREATE OR REPLACE package BNSTAGE.plsdbg as</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp procedure put(info varchar2);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp end;</TT>&nbsp;</TT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Body SQL&nbsp;</FONT></B></TD>
<TD><TT><TT>CREATE OR REPLACE package body BNSTAGE.plsdbg as</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp procedure put(info varchar2) is</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp status integer;&nbsp&nbsp -- ret. val. required for the</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp begin</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp sys.dbms_pipe.pack_message(info);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp status := sys.dbms_pipe.send_message('VANTAGE_PIPE',0, 4000000);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp end;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp end;</TT>&nbsp;</TT></TD>
</TR>
</TABLE>
<P>
<TABLE WIDTH=100% CELLPADDING=3 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="LIGHTGREY" ><B><FONT SIZE=4 FACE="Arial">PLSDBG Object Permissions&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">User/Role Name&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Grantee Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Permission Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Action Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Is Action Extended&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Is System&nbsp;</FONT></B></TD>
</TR>
<P>
<TABLE WIDTH=100% CELLPADDING=3 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="LIGHTGREY" ><B><FONT SIZE=4 FACE="Arial">PLSDBG Bound Attachments&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP  WIDTH=30% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Name&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=46% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Current Value&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<HR>
<A NAME = "Pack_55f3578f559d492dae2a05d74bfd40cb"></A>
<TABLE WIDTH=100% CELLPADDING=1 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="darkblue" ><B><FONT SIZE=5 COLOR="white" FACE="Arial">SYS_STUB_FOR_PURITY_ANALYSIS&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Owner&nbsp;</FONT></B></TD>
<TD><FONT SIZE=2 FACE="Arial">BNSTAGE&nbsp;</FONT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Description&nbsp;</FONT></B></TD>
<TD><FONT SIZE=2 FACE="Arial">&nbsp;</FONT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Header SQL&nbsp;</FONT></B></TD>
<TD><TT><TT>CREATE OR REPLACE package BNSTAGE.sys_stub_for_purity_analysis as</TT><BR><TT>&nbsp&nbsp procedure prds;</TT><BR><TT>&nbsp&nbsp pragma restrict_references(prds, wnds, rnps, wnps);</TT><BR><TT></TT><BR><TT>&nbsp&nbsp procedure pwds;</TT><BR><TT>&nbsp&nbsp pragma restrict_references(pwds, rnds, rnps, wnps);</TT><BR><TT></TT><BR><TT>&nbsp&nbsp procedure prps;</TT><BR><TT>&nbsp&nbsp pragma restrict_references(prps, rnds, wnds, wnps);</TT><BR><TT></TT><BR><TT>&nbsp&nbsp procedure pwps;</TT><BR><TT>&nbsp&nbsp pragma restrict_references(pwps, rnds, wnds, rnps);</TT><BR><TT>end sys_stub_for_purity_analysis;</TT>&nbsp;</TT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Body SQL&nbsp;</FONT></B></TD>
<TD><TT>&nbsp;</TT></TD>
</TR>
</TABLE>
<P>
<TABLE WIDTH=100% CELLPADDING=3 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="LIGHTGREY" ><B><FONT SIZE=4 FACE="Arial">SYS_STUB_FOR_PURITY_ANALYSIS Object Permissions&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">User/Role Name&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Grantee Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Permission Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Action Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Is Action Extended&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Is System&nbsp;</FONT></B></TD>
</TR>
<P>
<TABLE WIDTH=100% CELLPADDING=3 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="LIGHTGREY" ><B><FONT SIZE=4 FACE="Arial">SYS_STUB_FOR_PURITY_ANALYSIS Bound Attachments&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP  WIDTH=30% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Name&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=46% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Current Value&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<HR>
<A NAME = "Pack_1615c6cc66d34707aa8e6c0ae0735d4a"></A>
<TABLE WIDTH=100% CELLPADDING=1 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="darkblue" ><B><FONT SIZE=5 COLOR="white" FACE="Arial">UTL_HTTP&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Owner&nbsp;</FONT></B></TD>
<TD><FONT SIZE=2 FACE="Arial">BNSTAGE&nbsp;</FONT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Description&nbsp;</FONT></B></TD>
<TD><FONT SIZE=2 FACE="Arial">&nbsp;</FONT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Header SQL&nbsp;</FONT></B></TD>
<TD><TT><TT>CREATE OR REPLACE package BNSTAGE.utl_http is</TT><BR><TT></TT><BR><TT>&nbsp&nbsp -- Package UTL_HTTP contains functions REQUEST and REQUEST_PIECES for</TT><BR><TT>&nbsp&nbsp -- making HTTP callouts from PLSQL programs.</TT><BR><TT></TT><BR><TT>&nbsp&nbsp -- Function REQUEST takes a URL as its argument.&nbsp&nbsp Its return-type is a</TT><BR><TT>&nbsp&nbsp -- string of length 2000 or less, which contains up to the first 2000 bytes</TT><BR><TT>&nbsp&nbsp -- of the html result returned from the HTTP request to the argument URL.</TT><BR><TT></TT><BR><TT>&nbsp&nbsp function request (url in varchar2, proxy in varchar2 default NULL,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp wallet_path in varchar2 default NULL,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp wallet_password in varchar2 default NULL)</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp return varchar2;</TT><BR><TT>&nbsp&nbsp pragma restrict_references (request, wnds, rnds, wnps, rnps);</TT><BR><TT></TT><BR><TT>&nbsp&nbsp -- Function REQUEST_PIECES also takes a URL as its argument.&nbsp&nbsp Its</TT><BR><TT>&nbsp&nbsp -- return-type is a PLSQL-table of type UTL_HTTP.HTML_PIECES.&nbsp&nbsp Each</TT><BR><TT>&nbsp&nbsp -- element of that PLSQL-table is a string of length&nbsp&nbsp 2000. The</TT><BR><TT>&nbsp&nbsp -- final element may be shorter than 2000 characters.</TT><BR><TT></TT><BR><TT>&nbsp&nbsp type html_pieces is table of varchar2(2000) index by binary_integer;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp function request_pieces (url in varchar2,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp max_pieces natural default 32767,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp proxy in varchar2 default NULL,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp wallet_path in varchar2 default NULL,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp wallet_password in varchar2 default NULL)</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp return html_pieces;</TT><BR><TT>&nbsp&nbsp pragma restrict_references (request_pieces, wnds, rnds, wnps, rnps);</TT><BR><TT></TT><BR><TT>&nbsp&nbsp -- The elements of the PLSQL-table returned by REQUEST_PIECES are</TT><BR><TT>&nbsp&nbsp -- successive pieces of the data obtained from the HTTP request to that</TT><BR><TT>&nbsp&nbsp -- URL.&nbsp&nbsp Here is a typical URL:</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp http://www.oracle.com</TT><BR><TT>&nbsp&nbsp -- So a call to REQUEST_PIECES could look like the example below. Note the</TT><BR><TT>&nbsp&nbsp -- use of the plsql-table method COUNT to discover the number of pieces</TT><BR><TT>&nbsp&nbsp -- returned, which may be zero or more:</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp -- declare pieces utl_http.html_pieces;</TT><BR><TT>&nbsp&nbsp -- begin</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp pieces := utl_http.request_pieces('http://www.oracle.com/');</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp for i in 1 .. pieces.count loop</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp&nbsp .... -- process each piece</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp end loop;</TT><BR><TT>&nbsp&nbsp -- end;</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT></TT><BR><TT>&nbsp&nbsp -- The second argument to REQUEST_PIECES, "MAX_PIECES", is optional.&nbsp&nbsp It is</TT><BR><TT>&nbsp&nbsp -- the maximum number of pieces (each 2000 characters in length, except for</TT><BR><TT>&nbsp&nbsp -- the last, which may be shorter), that REQUEST_PIECES should return.&nbsp&nbsp If</TT><BR><TT>&nbsp&nbsp -- provided, that argument should be a positive integer.</TT><BR><TT></TT><BR><TT>&nbsp&nbsp -- Exceptional conditions:</TT><BR><TT></TT><BR><TT>&nbsp&nbsp -- If initialization of the http-callout subsystem fails (for</TT><BR><TT>&nbsp&nbsp -- environmental reasons, for example, lack of available memory)</TT><BR><TT>&nbsp&nbsp -- then exception UTL_HTTP.INIT_FAILED is raised:</TT><BR><TT></TT><BR><TT>&nbsp&nbsp init_failed exception;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp -- When the HTTP call fails (e.g., because of failure of the HTTP daemon;</TT><BR><TT>&nbsp&nbsp -- or because of the argument to REQUEST&nbsp&nbsp or REQUEST_PIECES cannot be</TT><BR><TT>&nbsp&nbsp -- interpreted as a URL because it is NULL or has non-HTTP syntax) then</TT><BR><TT>&nbsp&nbsp -- exception UTL_HTTP.REQUEST_FAILED is raised.</TT><BR><TT></TT><BR><TT>&nbsp&nbsp request_failed exception;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp -- Note that the above two exceptions, unless explicitly caught by an</TT><BR><TT>&nbsp&nbsp -- exception handler, will be reported by this generic message:</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp&nbsp ORA-06510: PL/SQL: unhandled user-defined exception</TT><BR><TT>&nbsp&nbsp -- which reports them as "user-defined" exceptions, although</TT><BR><TT>&nbsp&nbsp -- they are defined in this system package.</TT><BR><TT></TT><BR><TT>&nbsp&nbsp -- If any other exception is raised during the processing of the http</TT><BR><TT>&nbsp&nbsp -- request (for example, an out-of-memory error), then function REQUEST</TT><BR><TT>&nbsp&nbsp -- or REQUEST_PIECES reraises that exception.</TT><BR><TT></TT><BR><TT>&nbsp&nbsp -- When no response is received from a request to the given URL</TT><BR><TT>&nbsp&nbsp -- (for example, because no site corresponding to that URL is contacted)</TT><BR><TT>&nbsp&nbsp -- then a formatted html error message may be returned.&nbsp&nbsp For example:</TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp <HTML></TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp <HEAD></TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp <TITLE>Error Message</TITLE></TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp </HEAD></TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp <BODY></TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp <H1>Fatal Error 500</H1></TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp Can't Access Document:&nbsp&nbsp http://home.nothing.comm.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp <P></TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp <B>Reason:</B> Can't locate remote host:&nbsp&nbsp home.nothing.comm.</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp <P></TT><BR><TT>&nbsp&nbsp --</TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp <P><HR></TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp <ADDRESS><A HREF="http://www.w3.org"></TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp&nbsp CERN-HTTPD3.0A</A></ADDRESS></TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp </BODY></TT><BR><TT>&nbsp&nbsp --&nbsp&nbsp </HTML></TT><BR><TT>&nbsp&nbsp --</TT><BR><TT></TT><BR><TT>&nbsp&nbsp -- You should not expect for UTL_HTTP.REQUEST or UTL_HTTP.REQUEST_PIECES</TT><BR><TT>&nbsp&nbsp -- to succeed in contacting a URL unless you can contact that URL by using</TT><BR><TT>&nbsp&nbsp -- a browser on the same machine (and with the same privileges, environment</TT><BR><TT>&nbsp&nbsp -- variables, etc.)&nbsp&nbsp If REQUEST or REQUEST_PIECES fails (i.e., if it raises</TT><BR><TT>&nbsp&nbsp -- an exception, or returns a HTML-formatted error message, yet you believe</TT><BR><TT>&nbsp&nbsp -- that the URL argument is correct), please try contacting that same URL</TT><BR><TT>&nbsp&nbsp -- with a browser, to verify network availability from your machine.</TT><BR><TT>&nbsp&nbsp -- Keep in mind that you may have a proxy server set in your browser that</TT><BR><TT>&nbsp&nbsp -- need to be set with each utl_http request call using the optional proxy</TT><BR><TT>&nbsp&nbsp -- parameter.</TT><BR><TT></TT><BR><TT>&nbsp&nbsp -- A note on proxies: this package can also use environment variables to</TT><BR><TT>&nbsp&nbsp -- specify its proxy behavior.</TT><BR><TT>&nbsp&nbsp -- For example, on Unix, setting the environment variable</TT><BR><TT>&nbsp&nbsp -- 'http_proxy' to a URL specifies to use that service as the proxy server for</TT><BR><TT>&nbsp&nbsp -- HTTP requests.&nbsp&nbsp Setting the environment variable 'no_proxy' to a domain</TT><BR><TT>&nbsp&nbsp -- name specifies to not use the HTTP proxy server for URL's in that domain.</TT><BR><TT>end utl_http;</TT>&nbsp;</TT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Body SQL&nbsp;</FONT></B></TD>
<TD><TT><TT>CREATE OR REPLACE package body BNSTAGE.utl_http is</TT><BR><TT></TT><BR><TT>&nbsp&nbsp subtype opaque is number;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp -- return codes from webserver icx entrypoints in ndwsi.c.</TT><BR><TT>&nbsp&nbsp NDWICX_FAIL constant binary_integer := 0;</TT><BR><TT>&nbsp&nbsp NDWICX_SUCC constant binary_integer := 1;</TT><BR><TT>&nbsp&nbsp NDWICX_MOREDATA constant binary_integer := 2;</TT><BR><TT></TT><BR><TT>--------------------------------------------------------</TT><BR><TT>&nbsp&nbsp -- PIHTTINIT: Initialization of icx for single call.</TT><BR><TT>&nbsp&nbsp -- Creates the "context" struct</TT><BR><TT>&nbsp&nbsp function pihttinit return opaque;</TT><BR><TT>&nbsp&nbsp pragma interface (c, pihttinit, "pihttinit");</TT><BR><TT></TT><BR><TT>--------------------------------------------------------</TT><BR><TT>&nbsp&nbsp -- PIHTTCLNP: Cleanup of icx at termination of call.</TT><BR><TT>&nbsp&nbsp -- Destroys the "context", releases all memory allocated by icx.</TT><BR><TT>&nbsp&nbsp procedure pihttclnp (context opaque);</TT><BR><TT>&nbsp&nbsp pragma interface (c, pihttclnp, "pihttclnp");</TT><BR><TT></TT><BR><TT>--------------------------------------------------------</TT><BR><TT>&nbsp&nbsp -- CREATE_REQUEST</TT><BR><TT>&nbsp&nbsp function pihttcr_create_request</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (context opaque, url in varchar2)</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp return opaque;</TT><BR><TT>&nbsp&nbsp pragma interface (c, pihttcr_create_request, "pihttcr_create_request");</TT><BR><TT></TT><BR><TT>--------------------------------------------------------</TT><BR><TT>&nbsp&nbsp -- MAKE_REQUEST</TT><BR><TT>&nbsp&nbsp function pihttmr_make_request</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (context opaque,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp req opaque, piece out varchar2,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp piecesize in binary_integer) return binary_integer;</TT><BR><TT>&nbsp&nbsp pragma interface (c, pihttmr_make_request, "pihttmr_make_request");</TT><BR><TT></TT><BR><TT>--------------------------------------------------------</TT><BR><TT>&nbsp&nbsp -- FETCH_MORE_DATA</TT><BR><TT>&nbsp&nbsp function pihttfm_fetch_more</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (context opaque,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp req opaque, piece out varchar2,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp piecesize in binary_integer) return binary_integer;</TT><BR><TT>&nbsp&nbsp pragma interface (c, pihttfm_fetch_more, "pihttfm_fetch_more");</TT><BR><TT></TT><BR><TT>--------------------------------------------------------</TT><BR><TT>&nbsp&nbsp -- DESTROY_REQUEST</TT><BR><TT>&nbsp&nbsp procedure pihttdr_destroy_request</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (context opaque, request opaque);</TT><BR><TT>&nbsp&nbsp pragma interface (c, pihttdr_destroy_request, "pihttdr_destroy_request");</TT><BR><TT></TT><BR><TT>-------------------------------</TT><BR><TT>&nbsp&nbsp -- SET_PROXY</TT><BR><TT>&nbsp&nbsp function pihttsp_set_proxy</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (session_context opaque, proxy varchar2) return binary_integer;</TT><BR><TT>&nbsp&nbsp pragma interface (c, pihttsp_set_proxy, "pihttsp_set_proxy");</TT><BR><TT></TT><BR><TT>-------------------------------</TT><BR><TT>&nbsp&nbsp -- SET_WALLET</TT><BR><TT>&nbsp&nbsp function pihttsw_set_wallet</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (session_context opaque, req opaque, wallet_path varchar2,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp wallet_pwd varchar2) return binary_integer;</TT><BR><TT>&nbsp&nbsp pragma interface (c, pihttsw_set_wallet, "pihttsw_set_wallet");</TT><BR><TT></TT><BR><TT>-------------------------</TT><BR><TT></TT><BR><TT>&nbsp&nbsp /* Returns HTML result from HTTP request to <url>,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp as a PLSQL-table of varchar2(2000) pieces.</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp Returns at most <max_pieces> pieces. */</TT><BR><TT>&nbsp&nbsp function request_pieces (url in varchar2,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp max_pieces natural default 32767,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp proxy in varchar2 default NULL,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp wallet_path in varchar2 default NULL,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp wallet_password in varchar2)</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp return html_pieces is</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp ctx opaque;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp i binary_integer;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp req opaque;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp rc binary_integer;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp piece varchar2(2000);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp pieces html_pieces;</TT><BR><TT>&nbsp&nbsp begin</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp if url is null then raise request_failed; end if;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp ctx := pihttinit; -- pointer to ndwsictx struct</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp if ctx is null then raise init_failed; end if;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp if proxy is not null</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp then</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp rc := pihttsp_set_proxy(ctx, proxy);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if NDWICX_FAIL = rc then raise request_failed; end if;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp end if;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp req := pihttcr_create_request(ctx, url);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp if req is null then raise request_failed; end if;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp if wallet_path is not null</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp then</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp rc := pihttsw_set_wallet(ctx, req, wallet_path, wallet_password);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if NDWICX_FAIL = rc then raise request_failed; end if;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp end if;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp rc := NDWICX_SUCC; -- assumption</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp if 0 < max_pieces</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp then</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp rc := pihttmr_make_request(ctx, req, piece, 2000);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if NDWICX_FAIL = rc then raise request_failed; end if;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pieces(1) := piece;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp i := 2;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp while NDWICX_MOREDATA = rc and i <= max_pieces loop</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp rc := pihttfm_fetch_more(ctx, req, piece, 2000);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pieces(i) := piece;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp i := i + 1;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp end loop;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp end if;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp if NDWICX_FAIL = rc then raise request_failed; end if;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp pihttdr_destroy_request(ctx, req);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp pihttclnp(ctx);</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp return pieces;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp exception when others then</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp if req is not null then pihttdr_destroy_request(ctx, req); end if;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp if ctx is not null then pihttclnp(ctx); end if;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp raise;</TT><BR><TT>&nbsp&nbsp end request_pieces;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp -- Returns up to the first 2000 bytes of HTML result</TT><BR><TT>&nbsp&nbsp -- from HTTP request to <url>.</TT><BR><TT>&nbsp&nbsp function request (url in varchar2, proxy in varchar2 default NULL,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp wallet_path in varchar2 default NULL,</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp wallet_password in varchar2)</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp return varchar2 is</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp ctx opaque;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp i binary_integer;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp req opaque;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp rc binary_integer;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp piece varchar2(2000);</TT><BR><TT>&nbsp&nbsp begin</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp if url is null then raise request_failed; end if;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp ctx := pihttinit; -- pointer to ndwsictx struct</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp if ctx is null then raise init_failed; end if;</TT><BR><TT></TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp if proxy is not null</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp then</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp rc := pihttsp_set_proxy(ctx, proxy);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if NDWICX_FAIL = rc then raise request_failed; end if;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp end if;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp req := pihttcr_create_request(ctx, url);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp if req is null then raise request_failed; end if;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp if wallet_path is not null</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp then</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp rc := pihttsw_set_wallet(ctx, req, wallet_path, wallet_password);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if NDWICX_FAIL = rc then raise request_failed; end if;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp end if;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp rc := pihttmr_make_request(ctx, req, piece, 2000);</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp if NDWICX_FAIL = rc then raise request_failed; end if;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp pihttdr_destroy_request(ctx, req);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp pihttclnp(ctx);</TT><BR><TT></TT><BR><TT>&nbsp&nbsp&nbsp&nbsp return piece;</TT><BR><TT></TT><BR><TT>&nbsp&nbsp exception when others then</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp if req is not null then pihttdr_destroy_request(ctx, req); end if;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp if ctx is not null then pihttclnp(ctx); end if;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp raise;</TT><BR><TT>&nbsp&nbsp end request;</TT><BR><TT></TT><BR><TT>end utl_http;</TT>&nbsp;</TT></TD>
</TR>
</TABLE>
<P>
<TABLE WIDTH=100% CELLPADDING=3 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="LIGHTGREY" ><B><FONT SIZE=4 FACE="Arial">UTL_HTTP Object Permissions&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">User/Role Name&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Grantee Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Permission Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Action Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Is Action Extended&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Is System&nbsp;</FONT></B></TD>
</TR>
<P>
<TABLE WIDTH=100% CELLPADDING=3 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="LIGHTGREY" ><B><FONT SIZE=4 FACE="Arial">UTL_HTTP Bound Attachments&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP  WIDTH=30% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Name&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=46% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Current Value&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<HR>
<A NAME = "Pack_60894fc8067e4d6bbd409eaadffe3e22"></A>
<TABLE WIDTH=100% CELLPADDING=1 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="darkblue" ><B><FONT SIZE=5 COLOR="white" FACE="Arial">VANPIPE&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Owner&nbsp;</FONT></B></TD>
<TD><FONT SIZE=2 FACE="Arial">BNSTAGE&nbsp;</FONT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Description&nbsp;</FONT></B></TD>
<TD><FONT SIZE=2 FACE="Arial">&nbsp;</FONT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Header SQL&nbsp;</FONT></B></TD>
<TD><TT><TT>CREATE OR REPLACE package BNSTAGE.vanpipe as</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp procedure put(info varchar2);</TT><BR><TT>end;</TT>&nbsp;</TT></TD>
</TR>
<TR>
<TD VALIGN=TOP WIDTH=20%% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Body SQL&nbsp;</FONT></B></TD>
<TD><TT><TT>CREATE OR REPLACE package body BNSTAGE.vanpipe as</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp procedure put(info varchar2) is</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp status integer;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp begin</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp sys.dbms_pipe.pack_message(info);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp status := sys.dbms_pipe.send_message('VANTAGE_PIPE',0, 4000000);</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp end;</TT><BR><TT>&nbsp&nbsp&nbsp&nbsp&nbsp end;</TT>&nbsp;</TT></TD>
</TR>
</TABLE>
<P>
<TABLE WIDTH=100% CELLPADDING=3 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="LIGHTGREY" ><B><FONT SIZE=4 FACE="Arial">VANPIPE Object Permissions&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">User/Role Name&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Grantee Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Permission Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Action Type&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Is Action Extended&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=22% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Is System&nbsp;</FONT></B></TD>
</TR>
<P>
<TABLE WIDTH=100% CELLPADDING=3 BORDER=2>
<TR>
<TD VALIGN=TOP BGCOLOR="LIGHTGREY" ><B><FONT SIZE=4 FACE="Arial">VANPIPE Bound Attachments&nbsp;</FONT></B></TD>
</TR>
</TABLE>
<TABLE WIDTH=100% CELLPADDING=2 BORDER=2>
<TR>
<TD VALIGN=TOP  WIDTH=30% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Name&nbsp;</FONT></B></TD>
<TD VALIGN=TOP  WIDTH=46% bgcolor="#87BCFF"><B><FONT SIZE=2 FACE="Arial">Current Value&nbsp;</FONT></B></TD>
</TR>
</TABLE>
</BODY>
</HTML>
